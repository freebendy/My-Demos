#ifndef INSERTSORT_H
#define INSERTSORT_H

#include "common.h"

/**
  * 插入排序都采用in-place在数组上实现。具体算法描述如下：
  *
  *     1.从第一个元素开始，该元素可以认为已经被排序
  *     2.取出下一个元素，在已经排序的元素序列中从后向前扫描
  *     3.如果该元素（已排序）大于新元素，将该元素移到下一位置
  *     4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
  *     5.将新元素插入到该位置中
  *     6.重复步骤2
  *
  * 时间复杂度：
  *     如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，
  *     序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。最坏情况就是，序列
  *     是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数减去
  *     (n-1)次。平均来说插入排序算法复杂度为O(n2)。因而，插入排序不适合对于数据量比较大的排序
  *     应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。
  *
  * 空间复杂度：
  *      O(1)
  *
  * 稳定，可用于链表和数组。
  */

void insertSort( int array[], int length )
{
    for ( int i = 1; i < length; i++ )
    {
        for ( int j = i; j > 0 ; j-- )
        {
            if ( array[j] < array[j - 1] )
            {
                swap( array[j], array[j - 1] );
            }
        }
    }
}

#endif // INSERTSORT_H
